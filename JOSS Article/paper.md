---
title: 'NeuralFieldEq.jl: A flexible solver to compute Neural Field Equations in several scenarios'
tags:
  - Julia
  - Computational Neuroscience
  - Neural Field Equations
  - Stochastic Processes
  - Delayed Equations
  - Fast Fourier Transforms
authors:
  - name: Tiago Sequeira^[first author]
    orcid: 0000-0001-8579-3676
    affiliation: "1"
affiliations:
 - name: Instituto Superior TÃ©cnico - University of Lisbon
   index: 1
date: 02 November 2021
bibliography: paper.bib
---

# Summary

Since @hodgkinhuxley that mathematical modelling proved to be a prominent neuroscience research area. One of its main challenges is to describe phenomena like memory, perception, etc. These neurobiological processes occur in the cortex, a layer of the brain that contains approximately $10^{10}$ neurons distributed along $2500\,cm^2$ of surface area with $2.8\,mm$ of depth. Driven by such complex structure, @WilsonCowan and @Amari derived a model called Neural Field Equation (NFE), that treats the cerebral cortex as a continuum space being able to deal with these large scale dynamical neuronal patterns. The equation has the following form
\begin{equation}\label{eq:NFE}
  \alpha \frac{\partial V}{\partial t}\left(\mathbf{x},t\right) = I\left(\mathbf{x},t\right) - V\left(\mathbf{x},t\right) + \int_{\Omega} K\left(||\mathbf{x}-\mathbf{y}||_2\right)S\big[V\left(\mathbf{y},t\right)\big]\,\,d^2\mathbf{y},
\end{equation}
where $\Omega=[-\frac{L}{2},\frac{L}{2}]^d$ with $d=1,2$; $V(\mathbf{x},t)$ is the membrane potential at point $\mathbf{x} \in \Omega$ at time $t$; $I(\mathbf{x},t)$ is the external input applied to the neural field; $K\left(||\mathbf{x}-\mathbf{y}||_2\right)$ is the average strength of connectivity between neurons located at points $\mathbf{x}$ and $\mathbf{y}$, when the coupling is positive (negative) the synapses are excitatory (inhibitory); $S(V)$ is the firing rate function, which converts the potential to the respective firing rate result; And $\alpha$ is the constant decay rate.

Since then there have been endeavours to improve NFEs. For example, depending on the cortical region the axonal speed can vary between $100\,m/s$ to $1\,m/s$, so considering the time spent by the stimulus to travel from neurons at $y$ to the ones at $x$ leads us to formulate more accurate models. Or the noisy neuronal interactions, generated by the stochastic nature of the neuron or from extrinsic noise sources that can arise from inputs of other neuronal networks.

`NeuralFieldEq.jl` proposes to efficiently solve NFEs in the mentioned scenarios as well as the combination of stochastic neural fields with finite transmission speed.

# Statement of need

The classical quadrature methods to numerically approximate the integral present in \autoref{eq:NFE} have a complexity of $\mathcal{O}^{2}$ or $\mathcal{O}^{4}$ in 1D or 2D domains, respectively, making these methods unsuitable for efficient numerical approximations of NFEs. Although the this integral can be seen as a convolution, when considering finite signal velocities is no longer the case. @HuttRougier:2 proposed a novel numerical scheme that addresses the delayed version of \autoref{eq:NFE} that rewrites the integral into a convolutional form in order to apply a Fourier Transform to it, implying a substantially speed-up when computing delayed NFEs.

The numerical method that `NeuralFieldEq.jl` implements arose from the combination of the key idea developed by Hutt and Rougier for delayed neural fields in the stochastic scenario presented by @RiedlerChristian, where the authors proved the convergence of spectral methods applied to stochastic NFEs with additive white noise spatially correlated.

The performance of `Julia` [@Julia] code, when well written, designed and profiled, can be close to `C` or `Fortran` without sacrificing the usual features present in high-level languages. Also, the package makes use of the the multiple dispatch concept, allowing it to be flexible enough to handle NFEs in three different scenarios, 1D or 2D domains, non-delayed or delayed equations and deterministic or stochastic neural fields. These advantages were the trigger needed to develop a new user friendly and fast NFE solver, improving the `Python` solver written by @Simulator

# Package usage

The solver is divided into three steps:
- Introduce the parameters and functions using the structures `Input1D` or `Input2D`, depending on the domain dimension;
- Pre-process the NFE using the function `probNFE`;
- Solve the equation using the function `solveNFE` at time instants chosen by the user, with or without noise.

Once the solution is computed, we can access it at the previously selected instants. Considering `t=[ti,tj,tk]`, to get the solution at `tj`: `V(tj)` or `V(2)`. In the stochastic case, `Vsto(tj)` stands for the mean solution at `tj`, while for the trajectory `p` is `Vsto(tj,p)`. Also, the user can obtain a specific point in space and time, let `x=[x1,x2,...,xN]` be the discretised space vector, `V(x2,tj)` is the solution's value at `(x2,tj)`.

To illustrate the code usage we will show an example taken from @Kulikov1D.
```julia
using NeuralFieldEq, Plots
# 1D neural field
# Define function inputs, I, K and S
I(x,t) = -2.89967 + 8.0*exp(-x^2/(2.0*3^2)) - 0.5
K(x) = 2*exp(-0.08*sqrt(x^2))*(0.08*sin(pi*sqrt(x^2)/10)+cos(pi*sqrt(x^2)/10))
S(V) = V<=0.0 ? 0.0 : 1.0 # Heaviside function

# 1st Define parameters
a  = 1.0  # Constant decay      
v  = 20.0 # Finite axonal speed
V0 = 0.0  # Initial condition
L  = 100  # Domain length
N  = 512  # Number of nodes to discretise space
T  = 20.0 # Time span
n  = 200  # Number of nodes to discretise time
nf_1d = Input1D(a,v,V0,L,N,T,n,I,K,S); # Wrap inputs in structure Input1D

# 2nd use the function probNFE to pre-process inputs to solve the NFE
prob = probNFE(nf_1d)

# 3rd compute the solution using `solveNFE`.
tj = [5.0,10.0,20.0]   # Choose instants where the sol is saved
V  = solveNFE(prob,tj) # Solve the equation and save at tj
```
If we want to address the stochastic case we simply need to add extra arguments to `solveNFE`.
```julia
# Solve the stochastic equation 100 times
# Noise magnitude: eps = 0.05. Correlation coefficient: xi = 0.1
Vsto  = solveNFE(prob,tj,0.05,100)      # xi default value 0.1
Vsto2 = solveNFE(prob,tj,0.05,100,0.15) # xi = 0.15

# Handling the solutions
V(10.0)     # Returns the deterministic solution at t=10.0
Vsto(20.0)  # Returns the mean stochastic solution at t=20.0
Vsto(5.0,4) # Returns the 4th trajectory at t=5.0

x = V.x # Returns the spatial vector
plot(x,[V(1),Vsto(1),Vsto(1,4)],
     title ="Solutions at t=5",
     xlabel="x",
     ylabel="Action potential",
     label=["Deterministic solution"
            "Stochastic mean solution"
            "4th trajectory"])
```
![Caption for example figure.\label{fig:example}](plots1D.png){width=90%}

Or a 2D neural field presented by @HuttRougier:2.
```julia
using NeuralFieldEq, Plots

I(x,y,t) = (5.0/(32.0*pi))*exp(-(x^2+y^2)/32.0)
function K(x,y)
    A = 20.0/(10.0*pi)
    B = 14.0/(18.0*pi)
    return A*exp(-sqrt(x^2+y^2)) - B*exp(-sqrt(x^2+y^2)/3.0)
end
S(V) = V<=0.005 ? 0.0 : 1.0 # H(V-th)

a  = 1.0
v  = 2.0
V0 = 0.0
L  = 20
N  = 256
T  = 300.0
n  = 6000

nfe  = Input2D(a,v,V0,L,N,T,n,I,K,S);
prob = probNFE(nfe)
tj   = 0:0.2:T;
V    = solveNFE(prob,tj)

# Plotting
minmax_V = zeros(2,length(tj))
for i = 1:length(tj)
    minmax_V[1,i] = minimum(V(i))
    minmax_V[2,i] = maximum(V(i))
end
plot(tj,[minmax_V[1,:],minmax_V[2,:]],label=[minimum maximum])
```
![Caption for example figure.\label{fig:example}](plots2D.png){width=90%}

# Acknowledgements

A deep thank you to my professor Pedro Lima that kindly reviewed this article.

# References
